//leetcode
//268. Missing Number 考虑了求和的方法，一开始在计算不缺失数字的总和时出现了问题（另外的方法是异或和二分法吧）
int missingNumber(int* nums, int numsSize) {
    int sum = 0;
    int res = 0;
    for (int i = 0; i < numsSize; i++){
        sum += nums[i];
    }
    int tmp = (numsSize*(numsSize+1))/2;
    res = tmp - sum;
    return res;
}

//118. Pascal's Triangle
int** generate(int numRows, int** columnSizes) {
    if (numRows == 0) return 0;
    int **returnArray = (int*)malloc(sizeof(int*) * numRows);
    int *columnSizesA = (int*)malloc(sizeof(int)*numRows);
    int i; 
    int j;
    for (i = 0; i < numRows; i++){
        returnArray[i] = (int*)malloc(sizeof(int)*(i+1));
        
        columnSizesA[i] = i+1;
        for (j = 0; j <= i; j++){
            if (j == 0 || j == i)
            {
                returnArray[i][j] = 1; //returnArray[i-1][j];
            }
            else{
                returnArray[i][j] = returnArray[i-1][j] + returnArray[i-1][j-1];
            }
        }
    }
    *columnSizes = columnSizesA;
    return returnArray;
}  //第一次是在申请空间时出了点问题，后来简单改了下竟然通过了。因为是已经定义好的函数，所以目前一直不清楚int** columnSizes的作用在哪里

//203. Remove Linked List Elements
//删除链表中指定的元素，自己写的还是不靠谱，两种解法是根据discuss中参考来的。一开始就卡在如何设置前一个节点的上，没有想通如何存储当前节点的上一个节点
struct ListNode* removeElements(struct ListNode* head, int val) {
    /*struct ListNode *p = NULL;
    struct ListNode *p1 = NULL;
    if (head == NULL) return head;
    for (p = head; p != NULL; p = p->next)
    {
        if (p->val == val){
            if (p == head){
                head = head->next;
            }
            else{
                p1->next = p->next;
            }
    }
        else
        {
            p1 = p;
        }
    }*/
    struct ListNode *dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->val = 0;
    dummy->next = head;
    struct ListNode *prev = dummy;
    struct ListNode *curr = dummy->next;
    struct ListNode *NEXT = NULL;
    //prev->next = head;
    while(curr)
    {
        NEXT = curr->next;
        if (curr->val == val){
            prev->next = curr->next;
        }
        else{
            prev = curr;
        }
        curr = NEXT;
    }

    return dummy->next;
}
